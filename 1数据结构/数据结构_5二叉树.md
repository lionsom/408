# 第五章：树与二叉树

树重点掌握二叉树的性质，和二叉树的顺序存储和链式存储。以及线索二叉树。树的三种遍历也是经常考。在树的应用中，掌握二叉树排序树、二叉树平衡树、哈夫曼树。



## 1. 树-基本术语

> - 结点的度：结点拥有子树数，称为结点的度；
> - 树的度：树内部各结点的度的最大值；
>
> 
>
> - 叶结点：度为0的结点，称为叶结点（Leaf）或终端结点；
> - 分支结点：度不为0的结点，称为分支结点；

![](media_Guide/第五章/树_基本术语.png)



### 常见考点 - 树的性质

![](media_Guide/第五章/树性质总结.jpg)

1. 结点数 = 总度数 + 1

    结点的度 = 该结点有几个孩子（分支）

2. 树的度 VS m叉树

    ![](media_Guide/第五章/树性质2.png)

    3. 度为m的树**第 i 层**至多有**『m 的 i-1 次方』**个结点

        ![](media_Guide/第五章/树性质3.png)

    4. 等比求和公式![](media_Guide/第五章/树性质4.png)

5. ![](media_Guide/第五章/树性质5.jpg)

6. 向上取整![](media_Guide/第五章/树性质6.jpg)





## 2. 二叉树

![](media_Guide/第五章/二叉树定义.png)

![](media_Guide/第五章/二叉树五种状态.png)



### 特殊二叉树

* 满二叉树
* 完全二叉树
* 二叉排序树
* 平衡二叉树

![](media_Guide/第五章/满二叉树VS完全二叉树.png)

![](media_Guide/第五章/二叉排序树.jpg)![](media_Guide/第五章/平衡二叉树.jpg)



### 常见考点 - 二叉树性质

![](media_Guide/第五章/二叉树性质.jpg)

![](media_Guide/第五章/二叉树性质1.jpg)

![](media_Guide/第五章/二叉树性质2.jpg)

![](media_Guide/第五章/二叉树性质3.jpg)



### 常见考点 - 完全二叉树性质

![](media_Guide/第五章/完全二叉树性质1_1.jpg)

![](media_Guide/第五章/完全二叉树性质1_2.jpg)

![](media_Guide/第五章/完全二叉树性质2.jpg)



## 3. 二叉树存储结构

### 顺序存储

> 一般不推荐，只适合存储完全二叉树，这样不会浪费空间；

![](media_Guide/第五章/二叉树顺序存储.jpg)



### 链式存储

![](media_Guide/第五章/二叉树链式存储.jpg)

![](media_Guide/第五章/二叉树链式存储考点.jpg)





## 4. 二叉树遍历（前中后）

**二叉树递归特性**

> 1. 要么是空树；
> 2. 要是就是由『根节点+左子树+右子树』组成。

**顺序**

![](media_Guide/第五章/二叉树遍历.jpg)

### 手算练习

![](media_Guide/第五章/二叉树遍历01.jpg)![](media_Guide/第五章/二叉树遍历02.jpg)

![](media_Guide/第五章/二叉树遍历03.jpg)



### 代码

![](media_Guide/第五章/二叉树遍历代码.png)

### 应用

![](media_Guide/第五章/二叉树遍历应用.jpg)







## 5. 二叉树层序遍历

![](media_Guide/第五章/二叉树层序遍历.png)



### 代码

![](media_Guide/第五章/二叉树层序遍历代码.png)



## 6. 由序列构建二叉树

> **结论：若只给出一个二叉树前序、中序、后序、层序遍历序列的一种，无法确定这个唯一的二叉树。**

![](media_Guide/第五章/由遍历序列构造二叉树1.png)

![](media_Guide/第五章/由遍历序列构造二叉树2.png)

### 前序 + 中序

![](media_Guide/第五章/由遍历序列构造二叉树3.png)



### 后序 + 中序

![](media_Guide/第五章/由遍历序列构造二叉树4.png)



### 层序 + 中序

![](media_Guide/第五章/由遍历序列构造二叉树5.png)



### 为什么其他组合不行？

![](media_Guide/第五章/由遍历序列构造二叉树6.png)



### 回顾

![](media_Guide/第五章/由遍历序列构造二叉树7.png)





## 7. 线索二叉树

### 为什么引入线索二叉树

> 普通二叉树
>
> * 遍历必须从头开始
> * 找前驱、找后继很不方便，必须从头开始遍历

**如何找中序遍历序列中指定结点p的前驱？**

![](media_Guide/第五章/线索二叉树01.png)



![](media_Guide/第五章/线索二叉树02.png)



### 线索化（手算）

#### 中序二叉树线索化

> **核心**：利用n+1个空链域记录前驱与后继！！！

![](media_Guide/第五章/线索化二叉树_中序.png)

#### 前序二叉树线索化

![](media_Guide/第五章/线索化二叉树_前序.png)

#### 后序二叉树线索化

![](media_Guide/第五章/线索化二叉树_后序.png)



### 线索二叉树存储结构

![](media_Guide/第五章/线索二叉树存储结构.png)

#### 中序线索二叉树的存储

![](media_Guide/第五章/线索二叉树存储结构_中序.png)



#### 前序线索二叉树的存储

![](media_Guide/第五章/线索二叉树存储结构_前序.png)



#### 三种对比

![](media_Guide/第五章/线索二叉树存储结构_对比.png)



### 知识回顾

![](media_Guide/第五章/线索二叉树回顾.png)



### 二叉树线索化（代码）

**核心：对二叉树前序、中序、后序遍历的改造。**

#### 中序线索化

![](media_Guide/第五章/线索化_中序_代码1.png)

![](media_Guide/第五章/线索化_中序_代码2.png)



#### 先序线索化（循环问题）

> 问题：按照先序二叉树遍历，会导致循环！！！ERROR

![](media_Guide/第五章/线索化_先序_代码1.png)

![](media_Guide/第五章/线索化_先序_代码2.png)



#### 后序线索化

![](media_Guide/第五章/线索化_后序_代码1.png)

#### 回顾

![](media_Guide/第五章/线索化_代码_回顾.png)



### 在线索化二叉树中找前驱、后继

#### 中序线索二叉树 找 中序遍历后继



#### 先序线索二茶树



#### 后序线索二叉树





## 8.树的存储结构

![](media_Guide/第五章/树的存储结构.png)

### 双亲表示法（顺序存储）

![](media_Guide/第五章/8树存储_双亲表示法.png)



###  孩子表示法（顺序+链式存储）

![](media_Guide/第五章/8树存储_孩子表示法.png)



### 孩子兄弟表示法（链式存储）   

![](media_Guide/第五章/8树存储_孩子兄弟表示法.png)

### 树与二叉树转换（孩子兄弟表示法）

![](media_Guide/第五章/8树存储_孩子兄弟表示法_树与二叉树转换1.png)

![](media_Guide/第五章/8树存储_孩子兄弟表示法_树与二叉树转换2.png)



### 森林与二叉树转换

![](media_Guide/第五章/8森林与二叉树转换1.png)

![](media_Guide/第五章/8森林与二叉树转换2.png)





## 9.树与森林的遍历

### 树的先根遍历 - 深度优先遍历 

  ![](media_Guide/第五章/9树的先根遍历.png)

### 树的后根遍历 - 深度优先遍历

 ![](media_Guide/第五章/9树的后根遍历.png)

### 树的层序遍历 - 广度优先遍历

![](media_Guide/第五章/9树的层序遍历.png)

 

### 森林的先序遍历

> 两个方案：
>
> 1. 依次对各个树进行 **先根遍历**；
> 2. 将森林转换为二叉树，在进行 **先序遍历**。

![](media_Guide/第五章/9森林的先序遍历1.png)

![](media_Guide/第五章/9森林的先序遍历2.png)



### 森林的中序遍历

> 两个方案：
>
> 1. 依次对各个树进行 **后根遍历**；
> 2. 森林转为为二叉树，对二叉树进行 **中序遍历**。

![](media_Guide/第五章/9森林的中序遍历1.png)

![](media_Guide/第五章/9森林的中序遍历2.png)



### 森林遍历与树、二叉树

![](media_Guide/第五章/9森林遍历总结.png)



## 10.二叉排序树BST

![](media_Guide/第五章/10二叉排序树知识梳理.png)

### 二叉排序树定义

![](media_Guide/第五章/10二叉排序树定义.png)



### 查找

![](media_Guide/第五章/10二叉排序树查找1.png)

#### 递归VS非递归

![](media_Guide/第五章/10二叉排序树查找2.png)



### 查找效率分析

> 越平衡效率越高

#### 查找成功效率

![](media_Guide/第五章/10二叉排序树查找成功效率.png)



#### 查找失败效率

![](media_Guide/第五章/10二叉排序树查找失败效率.png)



### 插入 & 构造

![](media_Guide/第五章/10二叉排序树插入.png)

![](media_Guide/第五章/10二叉排序树构造.png)

### 删除

#### 叶结点删除

![](media_Guide/第五章/10二叉排序树删除1.png)

#### 只有一个子树

![](media_Guide/第五章/10二叉排序树删除2.png)

#### 左右子树

> 后继中找最小结点代替，同时删除最小结点a，最左下节点，没有左子树，用最小结点a的右子树代替，回到情况二：只有一个子树

![](media_Guide/第五章/10二叉排序树删除3_1.png)



> 用左子树最大的结点，由于最大结点一定是最右下节点，直接删除即可。

![](media_Guide/第五章/10二叉排序树删除3_2.png)





## （未完成）11 平衡二叉树（AVL树）

### 定义

![](media_Guide/第五章/11平衡二叉树定义.png)

### 插入

> 最小不平衡子树

![](media_Guide/第五章/11平衡二叉树最小不平衡.png)

### 插入新结点后，调整

![](media_Guide/第五章/11平衡二叉树不平衡情况.png)



// ..... 待续



### 查找效率分析





## 12.哈夫曼树

![](media_Guide/第五章/12哈夫曼树知识梳理.png)

### 带权路径长度

![](media_Guide/第五章/12哈夫曼树带权路径.png)

### 哈夫曼树定义

![](media_Guide/第五章/12哈夫曼树定义.png)

### 哈夫曼树构造

> 哈夫曼树构造并不唯一，但是WPL必然相同且为最优。

![](media_Guide/第五章/12哈夫曼树构造1.png)

![](media_Guide/第五章/12哈夫曼树构造2.png)



### 哈夫曼树编码

> 将通常的固定长度编码 ==》经过哈夫曼编码 ==》可变长度编码
>
> 用途：压缩文件

![](media_Guide/第五章/12哈夫曼树编码1.png)



> 前缀编码：避免解码歧义！！

![](media_Guide/第五章/12哈夫曼树编码2.png)



















# 第七章：查找

查找是基于排序的，有些乱序的序列需要先排好序后再查找。其中折半查找和查找树以及散列查找，hash函数经常考。

KMP算法 明白原理即可。



# 第八章：排序

排序的算法很多，408要求主要掌握内部排序。重点搞清楚 交换排序 和选择排序，要明白各种排序的优势在哪儿和时间复杂度。









# 《数据结构》考点

### 2.4 树和二叉树

- 树和二叉树的基本概念（选）

> 1.树的性质：区分树的度和图的度
> 2.二叉树的性质：
> （1）n0 = n2 +1;
> （2）完全二叉树i结点的左孩子为2i，右孩子为2i+1 (从1开始编号)

- 二叉树的存储方式（选）

> \1. 顺序存储，其实就是按照完全二叉树来存储
> \2. 链表存储：链表的空指针数 = 结点数n + 1

- 二叉树的遍历方式（选+算）

> 四种遍历方式（先序，中序，后序，层次）
> 其中先序中序后序不仅要掌握递归方式还要掌握非递归方式，层次遍历需要借助队列来实现；**[线索二叉树](https://www.zhihu.com/search?q=线索二叉树&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A165229143})**是在先序中序后序递归实现方式上的变形（重点）

- 二叉树的应用（选+应）

> \1. 并查集：图里面最小生成树的基础
> \2. 二叉排序树(算)：代码模板记住
> 3.平衡二叉树AVL(选)：掌握LL型、RR型、LR型、RL型的调整过程
> 3.哈夫曼树和[哈夫曼编码](https://www.zhihu.com/search?q=哈夫曼编码&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A165229143})(选+应)：不仅会画图还要会用文字来叙述

### 2.5 图

- 图的概念（选）

> \1. 图的度与树的度的区分
> \2. [有向图](https://www.zhihu.com/search?q=有向图&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A165229143})与无向图的区分（连通性，强连通性）
> \3. 简单路径与简单回路
> \4. 距离：最短路径

- 图的存储方式（选+应一个小问）

> \1. [邻接矩阵](https://www.zhihu.com/search?q=邻接矩阵&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A165229143})*
> \2. 邻接表*
> \3. 十字链表(有向图)
> \4. 邻接多重表(无向图)

- 图的遍历方式（选+算）

> \1. BFS：类似二叉树的层次遍历；注意BFS的变形--求单源最短路径
> \2. DFS：类似二叉树的先序遍历；
> **3. BFS与DFS都需要借助辅助数组visited[]来标记当前结点是否被访问过**
> **4. 图的遍历与图的连通性的关系\***

- 图的应用（选+应）

> **1. 最小生成树**
> （1）prim算法
> （2）Kruskal算法
> **2. 最短路径**
> （1）dijkstra算法
> （2）Floyd算法
> **3. [拓扑排序](https://www.zhihu.com/search?q=拓扑排序&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A165229143})：**可以用来判断图是否有环
> **4.关键路径**

### 2.6 查找

- 顺序查找（选）

> \1. 普通顺序表：进行普通的从小到大的遍历查找插入点，然后**插入**
> **2. 有序顺序表\*：**进行二分的思想进行查找插入点，然后**插入 --- 记住二分思想的核心代码**
> 以上两种方式由于都需要进行插入，故时间复杂度为O(n^2)

- 分块查找（选）

> 使用了索引表+查找表的结构：
> （1）索引表：有序表 --- 二分查找
> （2）查找表 --- 根据索引分块后采用顺序查找方式查找

- 二叉排序树、AVL树(平衡二叉树)、B树、B+树（选）

> \1. 二叉排序树上的查找
> \2. AVL树上的查找：其实就等效为二叉排序树上的查找，因为AVL树就是一颗二叉排序树
> \3. B树：
> （1）概念：包含m/2向上取整-1 <= n(非根结点) <= m-1；[叶子结点](https://www.zhihu.com/search?q=叶子结点&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A165229143})不含数据，数据存在索引上等
> （2）B树高度求法：logm^(n+1) <= h <= logm/2向下取整^(n+1)/2 + 1
> （3）B树插入：可能使B树高度h+1
> （4）B树删除：可能使B树高度h-1
> \4. B+树
> （1）B+树的概念
> （2）B+树与B树的区别
> **（3）B+树的特点：**数据都存在叶子结点上，非终端结点只起索引作用；B+树可以有两种查询方式
> **注意：B/B+一般是以选择题的形式考察，并且考察的深度不高，我们只需要学习基本知识就可以**

- 散列表（选+应）

> \1. [散列函数](https://www.zhihu.com/search?q=散列函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A165229143})：直接定址法、除留取余法是重点，其他了解即可
> \2. 处理冲突：
> （1）开放定址法：线性探测法、平方探测法、再散列法是重点
> （2）拉链法
> \3. 装填因子
> **4. 求散列表上查找成功/不成功的平均查找数\***

- KMP（选+算+应）

> KMP算法的核心是next[]数组，掌握**计算机的next[]数组，**这里说的计算机的next[]数组是相当于手动模拟的next[]数组而言的，408考察的是计算机的next[]数组
> 计算机next[] = 手动模拟的next[] **右移一位 + 1**
> **KMP算法记下来，注意KMP的特点是主串不回溯**

### 2.7 排序

- 插入排序（选）

> \1. 直接插入排序
> \2. 折半插入排序：引入二分思想
> \3. [希尔排序](https://www.zhihu.com/search?q=希尔排序&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A165229143})

- 交换排序（选+算）

> \1. 冒泡排序
> **2. 快速排序：把Partition函数当模板记下来**

- 选择排序（选）

> \1. 简单选择排序
> \2. 堆排序：向下调整 、向上调整
> （1）堆的构建：向下调整，这里的时间复杂度为O(n)要知道为什么
> （2）堆排序：向下调整

- 归并排序（选+算）

> 掌握Merge函数，当模板记下来

- 基数排序（选+算）

> 基数排序是给予非比较的排序
> 拓展：桶排序、计数排序

- 外部排序--多路归并排序（选）

> \1. 败者树：要会自己构建败者树，败者树可以减少比较次数
> \2. 置换-选择排序：划分初试归并段
> \3. 最佳归并树：减少归并过程中的I/O次数
> **注意：虽然外部排序的内容少，但是外部排序的难度比内部排序的难度要高，幸运的是外部排序基本以选择题形式考察；学习外部排序重点是学习思想，要去真正的理解它。**

------

## 3. 经验总结

1. 在408真题中的数据结构部分的题目可以看出：选择题大多考察相应结构/算法的中间过程，这就要求我们必须深刻的理解和熟练的掌握此结构/算法，能从计算机的角度出发去思考计算机处理这个问题处理的整个过程是什么样的，而不要从个人主观上出发去看此结构/算法，因为这样只是表面上搞懂了此结构/算法，但是一做题该错的还是错，不会的还是不会；大题部分重点在于积累和做题，因为408真题中算法大题和应用大题基本上每一年考察的知识点和思想都不是很相同，所有我们需要多去做大题，虽然大题比较难做，但是一点要坚持去把王道的课后大题都做完，一边做一边去思考，慢慢的就会变好。
2. 选择题经常有很多坑，做题不要想当然，写答案前多问问自己这题真的是这样？真的这麽简单？比别人想的更多才能比别人走的更远；大题主要强调的是思想，多去想想算法大题有什么其他的解法，应用大题考的知识点是哪些，一定要做到看完题目心中有数，方能不乱阵脚。





# 题目

