* 核心章节

![](images/001.png)

![](images/001_1.png)

# 一、数据链路层功能概述

* 链路：物理通道
* 数据链路：逻辑通道

![](images/002.png)

* 数据链路层核心：将网络层的数据**可靠**的传输到相邻结点的网络层。
* 如 Boos -> 秘书 -> 快递小哥
    * Boos = 网络层，提供数据
    * 秘书 = 数据链路层，整理数据，并使数据在传递过程中可能遇到的问题进行处理，最后再给相邻节点的网络层
    * 快递小哥 = 物理层，只传输数据

![](images/003.png)

![](images/004.png)



## 1.1 核心概念

**数据链路层** 在 **<u>物理层</u>** 提供服务的基础上，向 <u>**网络层**</u> 提供服务。

* 最基本的服务：**将源自网络层的数据<u>可靠</u>的传输到目标机器的网络层**
* 主要作用：**加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。**

1. 为网络层提供服务
    * 对**网络层**而言，数据链路层的基本任务是 **将源机器中来自网络层的数据传输到目标机器的网络层。**
    * 数据链路层通常为网络层提供的服务：
        * 无确认的无连接服务
        * 有确认的无连接服务
        * 有确认的面向连接服务
        * 注意：<u>**不存在**</u> 无确认的面向连接服务
2. 链路管理
    * 数据链路层连接的建立、维持、释放，主要用于面向连接服务
3. 组帧：帧定界、帧同步与透明传输
4. 流量控制
    * 限制发送方
5. 差错控制
    * 帧错
    * 位错



# 二、组帧

## 2.1 封装成帧

* 成帧：在数据前后加上首部和尾部，构成一个帧。
* 帧定界：首部和尾部包含很多控制信息，它们的一个重要作用就是 **确定帧的界限**，即帧定界。 
* 帧同步：接收方应能从接收到的二进制比特流中区分出帧的起始与终止。

![](images/006.png)



## 2.2 透明传输

1. 透明传输的概念

    透明传输：不管所传递的数据是什么样的比特组合，都应能在链路上传送。

2. 如何保证透明传输

    当传输数据中的比特组合恰巧与某个控制信息完全一样，此时，就必须采取适当的措施，使得接收方不会将这样的数据错误当作是某种控制信息。这样才能保证数据链路层的传输是透明的。



## 2.3 四种方法实现组帧

### a. 字符计数法

* 优点：简单
* 缺点：如果一个错误，会导致后面所有的帧都读取错位。

![](images/007.png)



### b. 字符填充法

* 如果数据是普通的文本，可以直接放在帧里，因为键盘输入的都是ASCII码，不可能与首部尾部冲突。
* 如果是二进制代码或图像，需要采用方法来规避，这里介绍 字符填充法。
* 字符填充法：遇到数据中与首部尾部相同的比特，则在前面加上特殊转义字符，接收端收到后，移除特殊的转移字符即可。

![](images/008.png)

![](images/009.png)



### c. 零比特填充法⭐️

* 固定首尾：01111110   中间六个1
* 数据组若遇到连续5个1，后面补充一个0，就不会存在与首尾相同的数据了。

![](images/010.png)



### d. 违规编码法⭐️

* 利用与曼彻斯特编码不同的编码进行区分。
* 因为曼彻斯特编码不可能出现『高-高』『低-低』的电平。

![](images/011.png)



### e. 总结

由于<u>字节计数法</u>中Count字段的脆弱性（其值若有差错将导致灾难性后果）及 <u>字符填充法</u>实现上的复杂性和不兼容性，

目前较普遍使用的 **帧同步法** 是 **比特填充法** 和 **违规编码法**。



# 三、差错控制（比特错）

![](images/028.png)



![](images/014.png)

![](images/015.png)



## 1. 检错编码

#### a. 奇偶校验码

> 特点：
>
> 1. 只能检测奇位错；
> 2. 不具备纠错能力。

![](images/016.png)

##### 例题解析

> 数据共7位，数据中有4个「1」，采用奇校验，末尾需要一个校验位，此时校验位为『1』时，才满足奇校验；
>
> 若数据中有5个『1』，此时校验位只为『0』，就可以满足奇校验了。
>
> A B C 中共有4个1，说明不满足奇校验，能够检测出错误了；
>
> D 中共有5个1，满足奇校验，所以无法检测出错误。



#### b. CRC循环冗余码

> 需要学会做题。（都是套路）
>
> **CRC有纠错能力，但链路层只用到了检错能力。**
>
> FCS的生成以及接收端CRC检验都是 **硬件** 完成，处理很快。

##### Ⅰ. 冗余码思想

先引入小学数学，假设要传递的数据为5，生成多项式为2，取余1（冗余码），发送时候 5 + 1 = 6 进行发送。

接收端收到后，自己校验下，取余为0，则数据正确。



##### Ⅱ. CRC冗余码基本步骤

* 第一步：先讲一长串的数据，拆分成固定长度的小比特组。
* 第二步：双方商定的除数（生成多项式），
    * ⭐️生成多项式的形式：
        * 1 直接给出 1101
        * 2 给出一个函数，需要自己算出，如：x<sup>3</sup> + x<sup>2</sup> + 1，补齐：1 * x<sup>3</sup> + 1 * x<sup>2</sup> + 0 * x<sup>1</sup> +  1 * x<sup>0</sup> ，去前面系数：1101
    * 计算出 FCS帧检验序列：d位 + r位0（这里的r位 是根据生成多项式r+1位得来） 除以 生成多项式，得到r位的FCS
        * 这里的除以：是模二，同0异1
* 第三步：接收方校验

![](images/017.png)



##### Ⅲ. 例题

**最终发送的数据 = 要发送的数据 + FCS帧检验序列**

第一步：计算冗余码

确定生成多项式为10011，共5位，阶为4，因为10011的多项式为：1 * x<sup>4</sup> + 0 * x<sup>3</sup> + 0 * x<sup>2</sup> + 1 * x<sup>1</sup> +  1 * x<sup>0</sup> ，此时的最高阶为4。

所以需要补足4位0 = 1101 011011 0000 除以 多项式 10011 得到余数 1110。（具体步骤手搓）

第二步：得到发送数据

所以最终发送数据 = 原数据1101 0110 11  +  FCS帧校验码1110

第三步：接收端校验，同样需要除以 生成多项式 10011，结果为0，则帧正确。

余数不为0，判断帧错，但无法精确到哪个bit错了，直接丢弃帧。

![](images/018.png)

![](images/019.png)

##### Ⅳ. CRC能确保可靠传输吗？

* 链路层经过CRC差错检验，能做到对帧的无差错接收。即『凡是接收端数据链路层接收的帧均无差错』
* CRC不能保证可靠传输，CRC只是对帧进行丢弃，所以接收端丢失了一个帧，还不是可靠传输，后续还需要进行帧处理。

![](images/020.png)



## 2. 纠错编码

#### a. 海明码

> 发现错误 -> 找到位置 -> 纠正错误



##### Ⅰ. 与上面两个码区别？

* 都需要额外加上校验码
    * 奇偶校验需要加1位
    * CRC循环冗余码，需要加上计算出来的FCS帧校验码
    * 海明码也需要额外加上校验码

* 校验码位置不同：
    * 奇偶校验 与 CRC 都在末尾加上
    * 海明码需要通过计算出插入的位置

![](images/021.png)



##### Ⅱ. 海明距离

海明距离：就是两个

> 为了检测 N 位错，则码距为 N+1；（码距为N，可检测出N-1位的bit错）
>
> 为了纠正 N 位错，则码距位 2N+1。

![](images/022.png)



##### Ⅲ. 海明码工作步骤

**1.确定校验码位数r**

![](images/023.png)

**2.确定校验码与数据的位置**

![](images/024.png)

**3.求出校验码的值**

> 使用偶校验
>
> eg：4、5、6、7位置 『1』的个数为偶数个，所以 X<sub>4</sub> = 0

![](images/025.png)

**4.检错并纠错**

> 纠错方法一：画图
>
> 纠错方法二：异或（同0异1）

![](images/026.png)

![](images/027.png)





# 四、流量控制与可靠传输机制⭐

## 1. 流量控制

**为什么需要进行流量控制？**

> 发送速率与接收速率不匹配，会造成传输出错，因此流量控制也是数据链路层的重要工作！！！

**流量控制在『链路层』与『传输层』都有，他们的区别？**

> * 区别一：对象不同
>
> 链路层的流量控制是 **点对点** 的（两个相邻节点之间）；传输层的流量控制是 **端到端** 的。
>
> 这里的点是指中间系统（网络层、数据链路层、物理层）；端是指发送端、接收端，有七层。
>
> * 区别二：控制手段不同
>
> 链路层流量控制的手段：接收方接收不下就不回复确认；
>
> 传输层流量控制的手段：接收端给发送端一个窗口公告。

![](images/029.png)

喂小猫的故事，小猫吃完了，没吃饱，就把碗推出来给铲屎官，铲屎官再给猫粮。如果猫吃饱了，就不会把碗推出来。



### a. 如何实现流量控制

> 利用 **滑动窗口** 机制实现对 **发送方** 的流量控制！！！

![](images/030.png)

* 停止-等待协议

  > 停止-等待协议 也算特殊的 滑动窗口协议，窗口为1 

* 滑动窗口协议

  * 后退N帧协议（GBN）
  * 选择重传协议（SR）

* 三个协议区别

![](images/031.png)



### b. 可靠传输、流量控制、滑动窗口三者关系

![](images/032.png)



## 2. 停止-等待协议

**停止-等待协议属于哪一层？**

> 前期链路通讯质量不好，链路层担起可靠传输的职责；
>
> 随着通讯质量的提高，出错少，所以链路层可暂时抛弃"可靠传输"的职责，将"可靠传输"这个职责交给『传输层』，而链路层主要负责"差错控制"，从而提升数据在链路上传输的速度。
>
> 所以不必纠结属于哪一层， 因为最终影响的只是传输数据的对象，在传输层叫分组，在链路层叫帧。本质上都是一样的，都是传送的数据。 

**为什么要有停止-等待协议？**

> 除了 **比特出错**，底层信道还会出现丢包问题。

![](images/033.png)



### 1. 停等 - 无差错情况

![](images/034.png)



### 2. 停等 - 有差错情况

#### a. 数据帧丢失

![](images/035.png)

#### b. 确认帧丢失

![](images/036.png)

#### c. 确认帧迟到

![](images/037.png)



### 3. 性能分析

> 优点：简单
>
> 缺点：**信道利用率低**

![](images/038.png)



#### a. 信道利用率&信道吞吐率

![](images/039.png)



#### b. 计算题

如上图：单向传播时延 30ms，往返时延RTT = 30ms * 2 = 60ms，

注意：题目未提及**确认帧的发送时延**，所以不考虑。

利用率 = 发送时延 / （发送端发送数据的时间 + RTT往返时延）

80% = A / (A + 60)

A = 240

A = L / C， L为T时间内发送的比特数，即该题目求解，C为发送方数据传输率4kb/s

240 ms = 0.24 s = L / 4kb/s

L = 960bit



### 4. 脑图时刻

![](images/040.png)



## 3. 后退N帧协议（GBN）

**出现的原因？**

> 停止-等待协议太闲了，利用率太低。

![](images/041.png)

### 1. 流程介绍

多个发送窗口，一个接收窗口。

ack返回可以累计返回，不需要每个都返回ack。

![](images/042.png)

#### a. 发送方需要处理

> ⭐***累计确认：表示n之前的帧全部正确！！***
>
> 后退N帧：超时后，未确认的帧都需要重传一遍！！

![](images/043.png)

#### b. 接收方需要处理

> 严格按顺序接收，若未收到特定的帧，后续帧都丢弃，接收方无需缓存任何失序帧。

![](images/044.png)

#### c. 整体流程

> 接收方就像吃汉堡，必须一层一层吃，丢了一层就不吃，必须等到那一层再继续往下吃。

![](images/045-1.png)

### 2. 滑动窗口的长度

> 区分 "帧编号" 与 "窗口编号"

解释：

如果使用2个bit对帧进行编号，也就是 00、01、10、11，那么发送窗口的尺寸应该在 [0,3] 之间。

为什么呢？如果窗口过大，帧编号会重复，导致分不清新帧和旧帧！！！

![](images/046.png)



### 3. GBN考研重点⭐

![](images/047.png)

### 4. 性能分析

![](images/048.png)



### 5. 计算题

![](images/049-1.png)

![](images/049.png)

### 6. 脑图时刻

![](images/050.png)



## 4. 选择重传协议（SR）

> SR: Selective Repeat

**出现的原因？**

> GBN的缺点：需要批量重传

![](images/051.png)

#### 流程介绍

![](images/052.png)

![](images/053.png)

![](images/054.png)

![](images/055.png)

#### 滑动窗口长度

![](images/056.png)

#### SR考研重点⭐

![](images/057.png)

#### 习题

![](images/058.png)

#### 脑图时刻

![](images/059.png)







# 五、传输数据使用的两种链路

![](images/060.png)



## 介质访问控制（广播）

> 介质访问控制：为了解决 **广播** 模式下 **通信干扰** 的问题。

![](images/061.png)



### 静态划分信道 - 信道划分介质访问控制

**什么是多路复用技术？（答案见下图）**

![](images/062.png)



#### 频分多路复用 FDM

> **Frequency Division Multiplexing**

![](images/063.png)

#### 时分多路复用 TDM

> **Time Division Multiplexing**

![](images/064.png)

缺点：等待时间固定，利用率比较低。

##### 统计时分复用 STDM（改进）

> **Statistical Time Division Multiplexing**
>
> 
>
> TDM VS STDM:
>
> ​	若最高速率为8000 bit/s
>
> ​	时分多路复用：平均2000 bit/s
>
> ​	统计时分复用：最高8000 bit/s 

![](images/065.png)



#### 波分多路复用 WDM

> **Wavelength Division Multiplexing**
>
> 只要记住：**光的频分多路复用**， 不常考。

![](images/066.png)



#### 码分多路复用 CDM

> CDM: Code Division Multiplexing
>
> 码分多路复用：将数据扭在一起，到了目的端，再拆分开。

**码分多址 CDMA （Code Division Multiple Access）**

![](images/067.png)

![](images/068.png)

**内积**

> 内积：向量内积
>
> 规格化内积：内积后，除以向量维数。

![](images/069.png)

![](images/070.png)

![](images/071.png)

**CDMA与CSMA混淆？**

> CS游戏是动态的，所以CSMA是 `动态分配信道` 中的 `随机访问介质控制`。



### 动态分配信道

> 也叫：**动态媒体接入控制 、 多点接入**
>
> 特点：信道并非在用户通信时固定分配给用户。



### 动态分配信道 - 轮询访问介质访问控制





### 动态分配信道 - 随机访问介质访问控制

> 特点：所有用户可以随机发送信息。**发送信息时占用全部带宽。**
>
> 又因为所有用户可以随机发送信息，导致可能在同一时间都发送信息，从而发生冲突，所以才有了以下解决冲突的几种协议。



#### ALOHA协议

##### 纯ALOHA协议 

> 





